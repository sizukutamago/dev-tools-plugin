#!/bin/bash
# Stop hook: フィードバック収集スクリプト
# セッション終了時に条件判断してフィードバックを保存

# デバッグログ
exec 2>> ~/.claude/feedback/debug.log

FEEDBACK_DIR="$HOME/.claude/feedback"
mkdir -p "$FEEDBACK_DIR"

# 標準入力からhookデータを読み取り
INPUT=$(cat)

# デバッグ
echo "=== $(date) ===" >> "$FEEDBACK_DIR/debug.log"

# 入力が空の場合は終了
if [ -z "$INPUT" ]; then
    echo '{"continue": true}'
    exit 0
fi

# transcript_path を抽出
if command -v jq &> /dev/null; then
    TRANSCRIPT_PATH=$(echo "$INPUT" | jq -r '.transcript_path // empty')
    SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // "unknown"')
else
    TRANSCRIPT_PATH=$(echo "$INPUT" | grep -o '"transcript_path":"[^"]*"' | cut -d'"' -f4)
    SESSION_ID=$(echo "$INPUT" | grep -o '"session_id":"[^"]*"' | cut -d'"' -f4)
fi

echo "TRANSCRIPT_PATH=$TRANSCRIPT_PATH" >> "$FEEDBACK_DIR/debug.log"

# transcript_path がない、またはファイルが存在しない場合は終了
if [ -z "$TRANSCRIPT_PATH" ] || [ ! -f "$TRANSCRIPT_PATH" ]; then
    echo "No transcript file found" >> "$FEEDBACK_DIR/debug.log"
    echo '{"continue": true}'
    exit 0
fi

# JSONLファイルからメッセージをカウント
if command -v jq &> /dev/null; then
    # jqでJSONLをパース
    MESSAGE_COUNT=$(wc -l < "$TRANSCRIPT_PATH" | tr -d ' ')
    TOOL_USES=$(grep -c '"tool_use"' "$TRANSCRIPT_PATH" 2>/dev/null || echo "0")
    CODE_CHANGES=$(grep -cE '"(Write|Edit|Bash)"' "$TRANSCRIPT_PATH" 2>/dev/null || echo "0")
else
    MESSAGE_COUNT=$(wc -l < "$TRANSCRIPT_PATH" | tr -d ' ')
    TOOL_USES=$(grep -c '"tool_use"' "$TRANSCRIPT_PATH" 2>/dev/null || echo "0")
    CODE_CHANGES=$(grep -cE '"(Write|Edit|Bash)"' "$TRANSCRIPT_PATH" 2>/dev/null || echo "0")
fi

echo "MESSAGE_COUNT=$MESSAGE_COUNT, TOOL_USES=$TOOL_USES, CODE_CHANGES=$CODE_CHANGES" >> "$FEEDBACK_DIR/debug.log"

# 収集条件の判定
SHOULD_COLLECT=false
REASON="none"

# 条件1: コード変更があった（Write/Edit/Bash使用）
if [ "$CODE_CHANGES" -gt 0 ]; then
    SHOULD_COLLECT=true
    REASON="code_changes"
fi

# 条件2: 3ステップ以上のツール使用
if [ "$TOOL_USES" -ge 3 ]; then
    SHOULD_COLLECT=true
    REASON="complex_task"
fi

# 条件3: 多くのメッセージ交換（実質的なセッション）
if [ "$MESSAGE_COUNT" -ge 10 ]; then
    SHOULD_COLLECT=true
    REASON="substantial_session"
fi

# スキップ条件: メッセージが少なすぎる（JSONLの行数ベース）
if [ "$MESSAGE_COUNT" -lt 6 ]; then
    SHOULD_COLLECT=false
    REASON="too_few_messages"
fi

echo "SHOULD_COLLECT=$SHOULD_COLLECT, REASON=$REASON" >> "$FEEDBACK_DIR/debug.log"

# 収集しない場合は終了
if [ "$SHOULD_COLLECT" = false ]; then
    echo '{"continue": true}'
    exit 0
fi

# フィードバックファイル生成
DATE=$(date +%Y%m%d)
TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

# シーケンス番号を決定
SEQ=1
while [ -f "$FEEDBACK_DIR/fb-$DATE-$(printf '%03d' $SEQ).yaml" ]; do
    SEQ=$((SEQ + 1))
done
FILENAME="fb-$DATE-$(printf '%03d' $SEQ).yaml"

# フィードバックテンプレート生成
cat > "$FEEDBACK_DIR/$FILENAME" << EOF
# Auto-generated by Stop hook
id: fb-$DATE-$(printf '%03d' $SEQ)
created_at: $TIMESTAMP
session_id: $SESSION_ID
transcript_path: $TRANSCRIPT_PATH

# セッション統計
stats:
  message_count: $MESSAGE_COUNT
  tool_uses: $TOOL_USES
  code_changes: $CODE_CHANGES
  collection_reason: $REASON

# 以下は手動または /improve で更新
task_summary: "TODO: タスク要約を記入"
outcome:
  success: null
  score: null
  rationale: "TODO: 評価理由を記入"
issues: []

# プライバシー
privacy:
  redacted: false

EOF

# Pythonスクリプトで詳細情報を抽出して追記
EXTRACT_SCRIPT="$HOME/.claude/scripts/extract_transcript.py"
if [ -f "$EXTRACT_SCRIPT" ] && command -v python3 &> /dev/null; then
    echo "Running extract_transcript.py..." >> "$FEEDBACK_DIR/debug.log"
    EXTRACTED=$(python3 "$EXTRACT_SCRIPT" "$TRANSCRIPT_PATH" 2>> "$FEEDBACK_DIR/debug.log")
    if [ -n "$EXTRACTED" ]; then
        echo "" >> "$FEEDBACK_DIR/$FILENAME"
        echo "# 自動抽出された詳細情報" >> "$FEEDBACK_DIR/$FILENAME"
        echo "$EXTRACTED" >> "$FEEDBACK_DIR/$FILENAME"
        echo "Extracted data appended" >> "$FEEDBACK_DIR/debug.log"
    else
        echo "No extracted data (script returned empty)" >> "$FEEDBACK_DIR/debug.log"
    fi
else
    echo "extract_transcript.py not found or python3 not available" >> "$FEEDBACK_DIR/debug.log"
fi

echo "SAVED: $FILENAME" >> "$FEEDBACK_DIR/debug.log"

# 成功メッセージを出力
echo '{"continue": true}'
